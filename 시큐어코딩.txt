파일 업로드, 암복호화시 사용되는 폴더의 순서와 로직 변경하기
jwt에 대해 학습하고, 코드 구현해 보기 - 취약점(세션부분)

예외로 인한 에러페이지 출력 처리함
sqlinjection은 mybatis의 #{}으로 해결함. - PreparedStatement
-> 부득이하게 ${}를 사용해야 하면,  @SQLInjectionSafe를 dto 필드에 적용시키면 됨

파일 업로드시 xss, 특수문자(쿼리문, ../와 같은 경로)가 포함되어도 안전함을 확인함
-> 특수문자가 내포되어 있기에, 위협은 아직은 있음 xss에 대해서 문자 치환으로 보완하기
-> 난독화된 코드 삭제 고민해 보기 -> 기본적인 글자수가 증가하고, 다양한 난독화 방식이 있어서 글자수를 제한하는 방식으로 우선 구현함.

경로조작공격에 대해서 한번 더 확인해 보고 수정할 내용이 있으면 수정하기
-> 업로드하고자 하는 파일명에 xss, ../와 같은 경로가 포함되면 업로드 예외 발생

LDAP공격 -> 사용자 아이디 입력에 특수문자 필터링 기능 추가

추가할 것
id, pw길이제한 추가하기 -> 완료

＊파라미터값 음수 입력시 예외 - 정수오버플로우 -> 업로드는 구현, 다운로드와 관리자 페이지에 검증코드 추가하기 -> 추가완료
＊다운로드 횟수 0이상, 10까지 제한하는 코드 구현하기 -> 구현 완료

이미 다운로드 허가된 파일을 다시 승인하면, 승인페이지가 나오는 것을 수정하기 -> 수정완료
SSRF -> 패스
http응답분할 취약점 필터 구현하기-> 개행문자와 같은 특수문자 예외발생 - 경로조작으로 방지됨
시스템 데이터 정보 노출 -> 예외 throw시, e.message()하는 부분을 전부 적절한 문자열로 변경함 
 SSTI- >공격을 시도해도, 타입 및 특수문자 필터에 걸러짐
코드 인젝션, xml인젝션, command 인젝션 등등
json 데이터 필터를 메서드에서 filter를 상속받아서 시큐리티에 적용하는데 성공함
base64 디코딩시 특수문자 포함시 예외 메시지처리

11월 9일 피드백
컨트롤러 예외에서 각각 분기에 대해서 처리하도록 구현되어 있지만, 상위를 하나 구현해서, runtime예외가 최상위로 가는지 테스트해보기
-> 테스트 결과 선언된 부분은 처리하고, 선언안된 부분은 최상위로 감

남은것
null일 수 있는 것들은 항상 검사하기
로그인 및 기타정보 전달시 암호화해서 전송
사용자 정보를 담는 필드가 클래스 필드이면 안됨


db null 처리 코드 수정하기
if문으로 validation check부분을 수행하던 부분을 스프링에서 제공해 주는 어노테이션 방식으로 구현해 보기
필터링 순서(지금은 상관이 없지만, 업무에서는 순서가 매우 중요하다)에 대해서 숙지하기.